#!/usr/bin/env python
import os, json
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

import time, sys, subprocess
from diploshic.parser import load_arg_dict

TEST_FRAC = 0.1
VALID_FRAC = 0.5
BATCH_SIZE = 50

pyExec = sys.executable
print(pyExec)
if "/" in sys.argv[0]:
    diploShicDir = "/".join(sys.argv[0].split("/")[:-1]) + "/"
else:
    diploShicDir = ""
    
argsDict = load_arg_dict()


if argsDict["mode"] in ["train", "predict"]:
    ###########################################################
    # Import a bunch of libraries if everything checks out
    import matplotlib
    matplotlib.use("Agg")
    import numpy as np

    from sklearn.model_selection import train_test_split
    from keras.utils import to_categorical
    from keras.callbacks import EarlyStopping, ModelCheckpoint

    from diploshic.network import construct_model
    from diploshic.dataloader import DADiploSHICDataLoader, DiploSHICDataLoader, load_fvecs_from_directory, load_empirical_fvecs_from_directory

    numSubWins = argsDict["numSubWins"]

if argsDict["mode"] == "train":
    empiricalDir = argsDict["empiricalDir"]
    trainingDir = argsDict["trainDir"]
    testingDir = argsDict["testDir"]
    epochOption = argsDict["epochs"]
    outputModel = argsDict["outputModel"]
    confusionFile = argsDict["confusionFile"]
    lossAccFile = argsDict["lossAccFile"]
    
    print("loading data now...")
    both, y = load_fvecs_from_directory(trainingDir, numSubWins)
    Y_test_emp = None
    if trainingDir == testingDir:
        X_train, X_test, y_train, y_test = train_test_split(both, y, test_size=TEST_FRAC)
    else:
        X_train = both
        y_train = y
        X_test, y_test = load_fvecs_from_directory(testingDir, numSubWins)
    if argsDict["domain_adaptation"]:
        if empiricalDir is None:
            # Load empirical data from train/test directory labeled empirical.fvec (NOT FOR SIM DATA -- FOR REAL DATA)
            emp = load_empirical_fvecs_from_directory(trainingDir, numSubWins)
            if trainingDir == testingDir:
                X_train_emp, X_test_emp = train_test_split(emp, test_size=TEST_FRAC)
            else:
                X_train_emp = emp
                emp = load_empirical_fvecs_from_directory(testingDir, numSubWins)
        else:
            # Load a directory of simulation data to use as "empirical data" and domain adaptation
            X_emp, y_emp = load_fvecs_from_directory(empiricalDir, numSubWins)
            X_train_emp, X_test_emp, y_train_emp, y_test_emp = train_test_split(X_emp, y_emp, test_size=TEST_FRAC)
            Y_test_emp = to_categorical(y_test_emp, 5)
            Y_train_emp = to_categorical(y_train_emp, 5)
            
    Y_train = to_categorical(y_train, 5)
    Y_test = to_categorical(y_test, 5)
    X_valid, X_train, Y_valid, Y_train = train_test_split(X_train, Y_train, test_size=VALID_FRAC)
    if argsDict["domain_adaptation"]:
        if Y_train_emp is not None:
            X_valid_emp, X_train_emp, Y_valid_emp, Y_train_emp = train_test_split(X_train_emp, Y_train_emp, test_size=VALID_FRAC)
        else:
             X_valid_emp, X_train_emp = train_test_split(X_train_emp, test_size=VALID_FRAC)
        datagen = DADiploSHICDataLoader(X_train, X_train_emp, Y_train, batch_size=BATCH_SIZE)
        validation_gen = DADiploSHICDataLoader(X_valid, X_valid_emp, Y_valid, batch_size=BATCH_SIZE)
        test_gen = DADiploSHICDataLoader(X_test, X_test_emp, Y_test, batch_size=BATCH_SIZE)
        test_emp_gen = DADiploSHICDataLoader(X_test_emp, X_test_emp, Y_test_emp, batch_size=BATCH_SIZE)
    else:
        datagen = DiploSHICDataLoader(X_train, Y_train, batch_size=BATCH_SIZE)
        validation_gen = DiploSHICDataLoader(X_valid, Y_valid, batch_size=BATCH_SIZE)
        test_gen = DiploSHICDataLoader(X_test, Y_test, batch_size=BATCH_SIZE)

    print("training set has %d examples (%d batches of %d)" % (X_train.shape[0], X_train.shape[0] / BATCH_SIZE, BATCH_SIZE))
    print("validation set has %d examples (%d batches of %d)" % (X_valid.shape[0], X_valid.shape[0] / BATCH_SIZE, BATCH_SIZE))
    print("test set has %d examples (%d batches of %d)" % (X_test.shape[0], X_test.shape[0] / BATCH_SIZE, BATCH_SIZE))
    if argsDict["domain_adaptation"]:
        print("empirical training set has %d examples (%d batches of %d)" % (X_train_emp.shape[0], X_train_emp.shape[0] / BATCH_SIZE, BATCH_SIZE))
        print("empirical validation set has %d examples (%d batches of %d)" % (X_train_emp.shape[0], X_train_emp.shape[0] / BATCH_SIZE, BATCH_SIZE))

    model = construct_model(X_train.shape[1:], domain_adaptation=argsDict["domain_adaptation"], da_weight=argsDict["da_weight"], pred_weight=argsDict["pred_weight"])

    model_json = model.to_json()
    with open(outputModel + ".json", "w") as json_file:
        json_file.write(model_json)
    modWeightsFilepath = outputModel + ".weights.hdf5"
    
    monitor = "val_predictor_masked_categorical_accuracy" if argsDict["domain_adaptation"] else "val_masked_categorical_accuracy"
    earlystop = EarlyStopping(
        monitor=monitor,
        min_delta=0.001,
        patience=5,
        verbose=1,
        mode="auto",
    )
    checkpoint = ModelCheckpoint(
        modWeightsFilepath,
        monitor=monitor,
        verbose=1,
        save_best_only=True,
        save_weights_only=True,
        mode="auto",
    )
    # callbacks_list = [checkpoint]
    callbacks_list = [earlystop, checkpoint]
    start = time.time()

    if argsDict["domain_adaptation"]:
        training_history = model.fit(
            datagen,
            steps_per_epoch=len(X_train) / BATCH_SIZE,
            epochs=epochOption,
            verbose=1,
            callbacks=callbacks_list,
            validation_data=validation_gen,
            validation_steps=len(X_valid) / BATCH_SIZE,
        )
        score = model.evaluate(
            test_gen,
            steps=len(Y_test) / BATCH_SIZE, 
            return_dict=True)
        #predictions = model.predict(X_test)
        #preds = np.argmax(predictions, axis=1)
        score_emp = model.evaluate(test_emp_gen, steps = len(Y_test_emp) / BATCH_SIZE, return_dict=True)
        #emppredictions = model.predict(X_test_emp)
        #emppreds = np.argmax(emppredictions, axis=1)
    else:
        training_history = model.fit(
            datagen, 
            steps_per_epoch=len(X_train) / BATCH_SIZE,
            epochs=epochOption,
            verbose=1,
            callbacks=callbacks_list,
            validation_data=validation_gen, 
            validation_steps=len(X_valid) / BATCH_SIZE,
        )
        score = model.evaluate(
            test_gen, 
            steps=len(Y_test) / BATCH_SIZE,
            return_dict=True
        )
        #predictions = model.predict(X_test)
        #preds = np.argmax(predictions, axis=1)
        if empiricalDir is not None:
            X_emp, y_emp = load_fvecs_from_directory(empiricalDir, numSubWins)
            X_train_emp, X_test_emp, y_train_emp, y_test_emp = train_test_split(X_emp, y_emp, test_size=TEST_FRAC)
            Y_test_emp = to_categorical(y_test_emp,5)
            emp_test_gen = DiploSHICDataLoader(X_test_emp, Y_test_emp, batch_size=BATCH_SIZE)
            score_emp = model.evaluate(emp_test_gen,
                                    steps = len(Y_test_emp) / BATCH_SIZE, 
                                    return_dict=True)
            #emppredictions = model.predict(X_test_emp)
            #emppreds = np.argmax(emppredictions, axis=1)            
                    
    sys.stderr.write(
        "total time spent fitting and evaluating: %f secs\n"
        % (time.time() - start)
    )
    #np.savez(outputModel + "_preds.npz", pred=preds, true=y_test)
    #if empiricalDir is not None:
    #    np.savez(outputModel + "_emp_preds.npz", pred=emppreds, true=y_test_emp)
    with open(outputModel + "_training_history.json", "w") as json_file:
        metadata = {'history': training_history.history, 'score': score}
        if empiricalDir is not None:
            metadata['score_emp'] = score_emp
        json.dump(metadata, json_file)
        
    if argsDict["domain_adaptation"]:
        print("evaluation on source test set:")
        print(f"diploSHIC loss: Predictor: {score['predictor_loss']:3f}, Discriminator: {score['discriminator_loss']:3f}")
        print(f"diploSHIC accuracy: Predictor: {score['predictor_masked_categorical_accuracy']:3f}, Discriminator: {score['discriminator_masked_binary_accuracy']:3f}")
        print("evaluation on target test set:")
        print(f"diploSHIC loss: Predictor: {score_emp['predictor_loss']:3f}, Discriminator: {score_emp['discriminator_loss']:3f}")
        print(f"diploSHIC accuracy: Predictor: {score_emp['predictor_masked_categorical_accuracy']:3f}, Discriminator: {score_emp['discriminator_masked_binary_accuracy']:3f}")
    else:
        print("evaluation on source test set:")
        print(f"diploSHIC loss: {score['loss']:3f}")
        print(f"diploSHIC accuracy: {score['masked_categorical_accuracy']:3f}")
        if empiricalDir is not None:
            print("evaluation on target test set:")
            print(f"diploSHIC loss: {score_emp['loss']:3f}")
            print(f"diploSHIC accuracy: {score_emp['masked_categorical_accuracy']:3f}")
            
    if lossAccFile:
        from diploshic.misc import plot_loss_acc
        import matplotlib.pyplot as plt
        fig = plot_loss_acc(training_history.history)
        plt.savefig(lossAccFile, bbox_inches="tight")
            
    if confusionFile:
        from diploshic.misc import plot_confusion_matrix
        import matplotlib.pyplot as plt
        plot_confusion_matrix(
            model,
            X_test,
            Y_test,
            labels=[0, 4, 2, 3, 1],
            display_labels=[
                "Hard",
                "Hard-linked",
                "Soft",
                "Soft-linked",
                "Neutral",
            ],
            cmap=plt.cm.Blues,
            normalize="true",
            domain_adaptation=argsDict["domain_adaptation"],
        )
        plt.savefig(confusionFile, bbox_inches="tight")
        if empiricalDir is not None:
            plot_confusion_matrix(model, X_test_emp, Y_test_emp, labels=[0, 4, 2, 3, 1], 
                                  display_labels=["Hard", "Hard-linked", "Soft", "Soft-linked", "Neutral"], cmap=plt.cm.Blues, normalize="true", 
                                  domain_adaptation=argsDict["domain_adaptation"])
            plt.savefig(confusionFile.replace(".png", "_empirical.png"), bbox_inches="tight")

elif argsDict["mode"] == "predict":
    from keras.models import model_from_json
    from keras.preprocessing.image import ImageDataGenerator
    import pandas as pd
    
    # import data from predictFile
    x_df = pd.read_table(argsDict["predictFile"])
    if argsDict["simData"]:
        testX = x_df[list(x_df)[:]].to_numpy()
    else:
        testX = x_df[list(x_df)[4:]].to_numpy()
    nDims = int(testX.shape[1] / numSubWins)
    testX = testX.reshape(testX.shape[0], nDims, numSubWins, 1)
    validation_gen = ImageDataGenerator(
        featurewise_center=True,
        featurewise_std_normalization=True,
        horizontal_flip=False,
    )
    validation_gen.fit(testX)

    # import model
    json_file = open(argsDict["modelStructure"], "r")
    loaded_model_json = json_file.read()
    json_file.close()
    model = model_from_json(loaded_model_json)
    # load weights into new model
    model.load_weights(argsDict["modelWeights"])
    print("Loaded model from disk")

    # get predictions
    preds = model.predict(validation_gen.standardize(testX))
    predictions = np.argmax(preds, axis=1)

    # np.repeat(0,len(h1)),np.repeat(1,len(n1)), np.repeat(2,len(s1)), np.repeat(3,len(ls1)), np.repeat(4,len(lh1)
    classDict = {
        0: "hard",
        1: "neutral",
        2: "soft",
        3: "linkedSoft",
        4: "linkedHard",
    }

    # output the predictions
    outputFile = open(argsDict["predictFileOutput"], "w")
    if argsDict["simData"]:
        outputFile.write(
            "predClass\tprob(neutral)\tprob(likedSoft)\tprob(linkedHard)\tprob(soft)\tprob(hard)\n"
        )
    else:
        outputFile.write(
            "chrom\tclassifiedWinStart\tclassifiedWinEnd\tbigWinRange\tpredClass\tprob(neutral)\tprob(likedSoft)\tprob(linkedHard)\tprob(soft)\tprob(hard)\n"
        )

    for index, row in x_df.iterrows():
        if argsDict["simData"]:
            outputFile.write(
                "{}\t{:f}\t{:f}\t{:f}\t{:f}\t{:f}\n".format(
                    classDict[predictions[index]],
                    preds[index][1],
                    preds[index][3],
                    preds[index][4],
                    preds[index][2],
                    preds[index][0],
                )
            )
        else:
            outputFile.write(
                "{}\t{}\t{}\t{}\t{}\t{:f}\t{:f}\t{:f}\t{:f}\t{:f}\n".format(
                    row["chrom"],
                    row["classifiedWinStart"],
                    row["classifiedWinEnd"],
                    row["bigWinRange"],
                    classDict[predictions[index]],
                    preds[index][1],
                    preds[index][3],
                    preds[index][4],
                    preds[index][2],
                    preds[index][0],
                )
            )
    outputFile.close()
    print("{} predictions complete".format(index + 1))
elif argsDict["mode"] == "fvecSim":
    if argsDict["shicMode"].lower() == "diploid":
        cmdArgs = [
            argsDict["msOutFile"],
            argsDict["totalPhysLen"],
            argsDict["numSubWins"],
            argsDict["maskFileName"],
            argsDict["vcfForMaskFileName"],
            argsDict["popForMask"],
            argsDict["sampleToPopFileName"],
            argsDict["unmaskedGenoFracCutoff"],
            argsDict["chrArmsForMasking"],
            argsDict["unmaskedFracCutoff"],
            argsDict["outStatsDir"],
            argsDict["fvecFileName"],
        ]
        cmd = (
            pyExec
            + " "
            + diploShicDir
            + "makeFeatureVecsForSingleMsDiploid.py "
            + " ".join([str(x) for x in cmdArgs])
        )
    elif argsDict["shicMode"].lower() == "haploid":
        cmdArgs = [
            argsDict["msOutFile"],
            argsDict["totalPhysLen"],
            argsDict["numSubWins"],
            argsDict["maskFileName"],
            argsDict["ancFileName"],
            argsDict["chrArmsForMasking"],
            argsDict["unmaskedFracCutoff"],
            argsDict["pMisPol"],
            argsDict["outStatsDir"],
            argsDict["fvecFileName"],
        ]
        cmd = (
            pyExec
            + " "
            + diploShicDir
            + "makeFeatureVecsForSingleMs_ogSHIC.py "
            + " ".join([str(x) for x in cmdArgs])
        )
    else:
        sys.exit("'shicMode' must be set to either 'diploid' or 'haploid'")
    print(cmd)
    subprocess.call(cmd.split())
elif argsDict["mode"] == "fvecVcf":
    if argsDict["shicMode"].lower() == "diploid":
        cmdArgs = [
            argsDict["chrArmVcfFile"],
            argsDict["chrArm"],
            argsDict["chrLen"],
            argsDict["targetPop"],
            argsDict["winSize"],
            argsDict["numSubWins"],
            argsDict["maskFileName"],
            argsDict["unmaskedFracCutoff"],
            argsDict["unmaskedGenoFracCutoff"],
            argsDict["sampleToPopFileName"],
            argsDict["statFileName"],
            argsDict["fvecFileName"],
        ]
        cmd = (
            pyExec
            + " "
            + diploShicDir
            + "makeFeatureVecsForChrArmFromVcfDiploid.py "
            + " ".join([str(x) for x in cmdArgs])
        )
    elif argsDict["shicMode"].lower() == "haploid":
        cmdArgs = [
            argsDict["chrArmVcfFile"],
            argsDict["chrArm"],
            argsDict["chrLen"],
            argsDict["targetPop"],
            argsDict["winSize"],
            argsDict["numSubWins"],
            argsDict["maskFileName"],
            argsDict["unmaskedFracCutoff"],
            argsDict["sampleToPopFileName"],
            argsDict["ancFileName"],
            argsDict["statFileName"],
            argsDict["fvecFileName"],
        ]
        cmd = (
            pyExec
            + " "
            + diploShicDir
            + "makeFeatureVecsForChrArmFromVcf_ogSHIC.py "
            + " ".join([str(x) for x in cmdArgs])
        )
    else:
        sys.exit("'shicMode' must be set to either 'diploid' or 'haploid'")
    additionalArgs = []
    if argsDict["segmentStart"] != "None":
        additionalArgs += [argsDict["segmentStart"], argsDict["segmentEnd"]]
        cmd += " " + " ".join(additionalArgs)
    print(cmd)
    subprocess.call(cmd.split())
elif argsDict["mode"] == "makeTrainingSets":
    cmdArgs = [
        argsDict["neutTrainingFileName"],
        argsDict["softTrainingFilePrefix"],
        argsDict["hardTrainingFilePrefix"],
        argsDict["sweepTrainingWindows"],
        argsDict["linkedTrainingWindows"],
        argsDict["outDir"],
    ]
    cmd = (
        pyExec
        + " "
        + diploShicDir
        + "makeTrainingSets.py "
        + " ".join([str(x) for x in cmdArgs])
    )
    print(cmd)
    subprocess.call(cmd.split())
